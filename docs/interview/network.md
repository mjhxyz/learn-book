# 计算机网络

## 浏览器输入网址后发生了什么?

1. HTTP: 解析 URL, 获取协议、域名、端口、路径、查询参数等信息, 生成 HTTP 请求报文
2. DNS: 根据域名解析出 IP 地址, 本地域名服务器 -> 根域名服务器 -> 顶级域名服务器 -> 权威域名服务器
3. 协议栈: 获取到 IP 后，将 HTTP 的传输工作交给操作系统的 `协议栈`, 浏览器通过调用 socket 库，来委托协议栈工作
4. TCP: 建立 TCP 连接需要进行三次握手, 组成好 TCP 数据包后，传给 IP 层
5. IP: 封装成网络包, 里面有源 IP、目标 IP(DNS)。其中源 IP, 是客户端的 IP 地址, 如果客户端有多个网卡, 通过路由表来选择一个网卡。封装后的网络包给下一站 MAC 层
6. MAC: 进行两点间的传输。要有`发送方MAC`,`接收方MAC`。发送方 MAC 是网卡生产时写入 ROM里面的。接收方`MAC`是通过`ARP`协议获取的。
7. 网卡: 网卡驱动获取网络包之后，会将其复制到网卡内的缓存区中, 网卡驱动程序，使用网卡`将数字信息转换为电信号`
8. 交换机: 二层网络设备(无IP无MAC), 通过 MAC 地址来转发数据包, 会维护一个 MAC 地址表, 用于记录 MAC 地址和端口的对应关系, 交换机根据 MAC 地址表查找 MAC 地址，然后将信号发送到相应的端口。不存在的话会广播出去
9. 路由器: 三层网络设备(有IP有MAC), 和网卡差不多。
   1.  检查MAC地址, 如果是给自己的，那就接收并去除MAC头给到IP层,查询IP地址,使用路由表判断转发的目标，找到网关地址。
   2. 拿到下一步的IP后, 又能通过ARP协议获取到下一步的MAC地址, 然后再封装成MAC头, 通过网卡发送出去
10. 服务器: 拿到数据后，检查 MAC，检查IP, 检查IP的时候就可以拿上一层是TCP协议, 交给TCP协议栈处理。TCP协议栈解析TCP报文，里面又序列号, 需要看一下这个序列号是不是我想要的，如果是就放入缓冲区中，然后返回一个ACK，不是的话则丢弃。等到缓冲区中的数据有序了之后，因为TCP报文里面有端口号，可以找到监听这个端口号的应用程序，将数据交给应用程序处理。
11. 应用程序: 应用程序处理完之后，会返回一个响应报文, 通过协议栈，封装成 TCP 报文, 通过协议栈，封装成 IP 报文, 通过协议栈，封装成 MAC 报文, 通过网卡，发送出去

## 三次握手

### 三次握手的流程是什么样的?

1. 第一个ACK报文
   1. 客户端发送 SYN 报文到服务器, 进入 `SYN_SEND` 状态
   2. 服务端接收到 SYN 报文, 进入 `SYN_RECV` 状态
2. 第二个SYNC+ACK报文
    1. 服务端回复 SYN+ACK 报文, 进入 `SYN_RECV` 状态
    2. 客户端接收到 SYN+ACK 报文, 进入 `ESTABLISHED` 状态
3. 第三个ACK报文
    1. 客户端回复 ACK 报文, 进入 `ESTABLISHED` 状态
    2. 服务端接收到 ACK 报文, 进入 `ESTABLISHED` 状态

### 为什么需要三次握手?

1. 阻止重复历史连接的初始化
    1. 当旧的 SYN 报文先到达服务端，服务端回⼀个ACK+SYN报文
    2. 客户端收到后可以根据⾃⾝的上下文，判断这是⼀个历史连接（序列号过期或超时）
    3. 那么客户端会发送 RST, 终止这次连接
    4. 两次握手在收到服务端的响应后开始发送数据，不能判断当前连接是否是历史连接
    5. 三次握手可以在客户端准备发送第三次报文时, 有足够的上下文判断当前连接是否是历史连接
2. 可以同步双方的初始化序列号
3. 确认双方能正确的接收和发送数据
4. 避免资源浪费

## 四次挥手

### 四次挥手的流程是什么样的?

1. 第一个FIN报文
    1. 客户端发送 FIN 报文, 进入 `FIN_WAIT1` 状态
    2. 服务端接收到 FIN 报文, 进入 `CLOSE_WAIT` 状态
2. 第二个ACK报文
    1. 服务端回复 ACK 报文, 进入 `CLOSE_WAIT` 状态
    2. 客户端接收到 ACK 报文, 进入 `FIN_WAIT2` 状态
3. 第三个FIN报文
    1. 服务端发送 FIN 报文, 进入 `LAST_ACK` 状态
    2. 客户端接收到 FIN 报文, 进入 `TIME_WAIT` 状态
4. 第四个ACK报文
    1. 客户端回复 ACK 报文, 进入 `TIME_WAIT` 状态
    2. 服务端接收到 ACK 报文, 进入 `CLOSED` 状态
5. 客户端等待 2MSL 后, 进入 `CLOSED` 状态

### 为什么需要四次挥手?

- 关闭连接时，客户端发送 `FIN` 报文，表示客户端没有数据要发送了, 但是服务端可能还有数据要发送, 所以还能接收数据
- 服务端接收到 `FIN` 报文后, 会回复 `ACK` 报文, 表示已经接收到了客户端的 `FIN` 报文, 但是服务端可能还有数据要发送, 所以还能发送数据
- 等到服务端数据发送完毕，清理完毕后, 会发送 `FIN` 报文, 表示服务端没有数据要发送了

### 为什么 TIME_WAIT 状态需要等待 2MSL?

- MSL 指的是最大报文段生存时间, 也就是报文在网络中最长的生存时间, 超过这个时间，报文将被丢弃
- 等待 2MSL: 是因为网络中可能存在发送方的数据包，当这些发送⽅的数据包被接收⽅处理后又会向对⽅发送响应，
所以⼀来⼀回需要等待 2 倍的时间。
- 2MSL 是从客户端接收到 FIN 后发送 ACK 开始及时，如果在 TIME_WAIT 时间内, ACK
没有传输到服务端，客户端又接收到了服务端重发的 FIN 报文，那么 2MSL 时间将重新计时
- 也就保证了最后一个 ACK 报文能够到达服务端

### 为什么需要 TIME_WAIT 状态?

1. 防止相同的 `四元组` 的 `旧数据` 被收到
2. 保证被动关闭连接的一方能正确的关闭，即保证最后的 ACK 能让被动关闭⽅接收

有相同端⼜的 TCP 连接被复⽤后，被延迟的相同四元组的数据包抵达了客户端，那么客户端是有可能正常接收这个
过期的报⽂，这就会产⽣数据错乱等严重的问题。 

经过 2MSL 这个时间，⾜以让两个⽅向上的数据包都被丢弃，使得原来连接的数据包在⽹络中都⾃然消失，再出现
的数据包⼀定都是新建⽴连接所产⽣的。

### TIME_WAIT 过多有什么危害?

1. 内存资源占用
2. 端口资源占用, 一个TCP至少消耗一个本地端口号

## TCP

### 重传机制有哪些?分别是什么样的?

TCP 实现可靠传输方式之一，通过`序号`和`确认`应答, 但是这种方式并不能保证数据一定能够到达, 所以需要重传机制

**超时重传**

发送数据的时候，设定一个`定时器`,当超过`指定的时间`后，没有收到对端的 `ACK` 报文,就会重发该数据。

有两种情况会触发超时重传:

1. 数据包
2. ACK包丢失

`RTT`表示往返时延: `数据发送时刻到接收到确认的时刻的差值`

`RTO`表示 `重传超时时间`, 应该比 `RTT` 略大一点, 不过具体的值是一个变动的值，有专门的公式进行计算

- 当超时时间 `RTO 较大`时，重发就慢，丢了老半天才重发，没有效率，性能差；
- 当超时时间 `RTO 较小`时，会导致可能并没有丢就重发，于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发

每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的`两倍`。两次超时，就说明网络环境差，不宜频繁反复发送

超时触发重传存在的问题是，`超时周期可能相对较长`。可以用「快速重传」机制来解决超时重发的时间等待

**快速重传**

- 当序号 `n` 这个报文段丢失时, 但是 `n+1`, `n+2`, `n+3` 都到达了对端, 那么对端接收到 `n+1`,`n+2`,`n+3` 的时候，都会返回一个 `ACK(n+1)`
- 这样发送方就收到了三个 `ACK(n+1)`, 于是就知道了 `n` 丢失了, 就会立即重传 `n` 这个报文, 而`不需要等待超时重传`
- 快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文

因此快速重传解决了超时重传的`延迟问题`，但还是面临着重传的时候，是`重传一个，还是重传所有的问题`

比如 `n`, `n+1` 都丢失了，那么接收方在接收 `n+2`, `n+3`, `n+4` 后，都会返回 `ACK(n+1)`, 这样发送方就收到了三个 `ACK(n+1)`, 会触发快速重传, 但是发送放却不知道只有 `n` 丢失了，还是说后面的多少个也丢失了

为了解决不知道该重传哪些 TCP 报文，于是就有 `SACK` 方法

**SACK**

`SACK` 是 (Selective Acknowledgement) 的缩写, 也就是 `选择性确认`

需要在 TCP 报文头部选项中，添加一个 `SACK` 的字段, 可以将`已收到的数据`的信息`发送给发送方`,这样发送方就能知道收到了哪些报文, 就能知道哪些报文丢失了。
这样就可以只传输丢失的报文

比如 `n`, `n+1` 都丢失了，那么接收方在接收 `n+2`,`n+3`,`n+4`后，都会返回 `ACK(n+1)` 和 `SACK(n+2~n+4)`, 这样发送方就知道了 `n`, `n+1` 丢失了, 就可以只重传 `n`, `n+1`

`SACK` 必须要双方都支持, Linux 内核默认是支持的, `net.ipv4.tcp_sack`

**D-ACK**

上面都是通过 ACK 来触发重传, 但是 `ACK 也可能丢失`, 所以就有了 `D-ACK` 方法, 这是在 `SACK` 基础上的扩展

`D-ACK` 是 (Duplicate Acknowledgement) 的缩写, 也就是 `重复确认`, 主要用来告诉发送方,`有哪些数据被重复接收了`

比如 `n` 和 `n+1`, `n+2` 都成功的传输到了接收方，但是发送方没有成功接收到 ACK 报文，此时报文 `n` 触发超时重传, 接收方收到 `n` 号报文后，
`这时接收方发现数据是重复收到的, 于是回复了一个 SACK=n~n+2`, 告诉发送方 n~n+2已经被接收了, ACK=n+3, 此时这个 `SACK` 就代表这 `D-SACK`

此时发送方就知道了数据没有丢失，而是接收方的 ACK 丢失了

通过 `net.ipv4.tcp_dsack` 开启

### 滑动窗口是什么?有什么作用?


**滑动窗口概念**

如果 TCP 报文每发一个数据，都要进行一次确认应答，当上一个数据包收到应答，才发送下一个， 这样效率非常低下。

并且 `往返时间越长,通信效率就越低`

因此，为了解决这个问题，所以引入了 `窗口` 概念, 在往返时间较长的情况下，也不会降低通信的效率。

有了窗口后，可以指定窗口的大小，窗口大小指的是 `无需等待确认, 而可以继续发送数据的最大值`

其实就是在操作系统中申请的一个 `缓冲区` 发送方在等待确认到达之前，必须在缓冲区保留已经发送的数据，如果收到了ACK,则会将数据从缓冲区清除。

如果窗口大小为 3, 则 `n` `n+1` `n+2` 可以同时发送, 就算其中的一个 `n+1` 的 ACK 报文丢失了, 如果收到了 ACK(n+3), 也就是 `n+2` 的报文，也一样意味着之前的报文都已经接收了。这个模式就叫做 `累计确认` 或者 `累计应答`

**窗口大小怎么决定?**

TCP 头中有一个 `Window` 字段，也就是窗口大小

`这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来`

所以，通常窗口的大小是由`接收方的窗口大小来决定的`。

发送方发送的数据大小不能超过接收方的窗口大小，否则接收方就无法正常接收到数据。


### 流量控制是什么?有什么作用?

发送方发送数据的时候，要考虑接收方的处理能力，如果一直疯狂发送数据，接收方处理不过来，就会导致触发重发机制，从而导致网络流量浪费。


## HTTP/HTTPS

## HTTP2

## HTTP3
