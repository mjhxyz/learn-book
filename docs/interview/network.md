# 计算机网络

## 浏览器输入网址后发生了什么?

1. HTTP: 解析 URL, 获取协议、域名、端口、路径、查询参数等信息, 生成 HTTP 请求报文
2. DNS: 根据域名解析出 IP 地址, 本地域名服务器 -> 根域名服务器 -> 顶级域名服务器 -> 权威域名服务器
3. 协议栈: 获取到 IP 后，将 HTTP 的传输工作交给操作系统的 `协议栈`, 浏览器通过调用 socket 库，来委托协议栈工作
4. TCP: 建立 TCP 连接需要进行三次握手, 组成好 TCP 数据包后，传给 IP 层
5. IP: 封装成网络包, 里面有源 IP、目标 IP(DNS)。其中源 IP, 是客户端的 IP 地址, 如果客户端有多个网卡, 通过路由表来选择一个网卡。封装后的网络包给下一站 MAC 层
6. MAC: 进行两点间的传输。要有`发送方MAC`,`接收方MAC`。发送方 MAC 是网卡生产时写入 ROM里面的。接收方`MAC`是通过`ARP`协议获取的。
7. 网卡: 网卡驱动获取网络包之后，会将其复制到网卡内的缓存区中, 网卡驱动程序，使用网卡`将数字信息转换为电信号`
8. 交换机: 二层网络设备(无IP无MAC), 通过 MAC 地址来转发数据包, 会维护一个 MAC 地址表, 用于记录 MAC 地址和端口的对应关系, 交换机根据 MAC 地址表查找 MAC 地址，然后将信号发送到相应的端口。不存在的话会广播出去
9. 路由器: 三层网络设备(有IP有MAC), 和网卡差不多。
   1.  检查MAC地址, 如果是给自己的，那就接收并去除MAC头给到IP层,查询IP地址,使用路由表判断转发的目标，找到网关地址。
   2. 拿到下一步的IP后, 又能通过ARP协议获取到下一步的MAC地址, 然后再封装成MAC头, 通过网卡发送出去
10. 服务器: 拿到数据后，检查 MAC，检查IP, 检查IP的时候就可以拿上一层是TCP协议, 交给TCP协议栈处理。TCP协议栈解析TCP报文，里面又序列号, 需要看一下这个序列号是不是我想要的，如果是就放入缓冲区中，然后返回一个ACK，不是的话则丢弃。等到缓冲区中的数据有序了之后，因为TCP报文里面有端口号，可以找到监听这个端口号的应用程序，将数据交给应用程序处理。
11. 应用程序: 应用程序处理完之后，会返回一个响应报文, 通过协议栈，封装成 TCP 报文, 通过协议栈，封装成 IP 报文, 通过协议栈，封装成 MAC 报文, 通过网卡，发送出去

## 三次握手

### 三次握手的流程是什么样的?

1. 第一个ACK报文
   1. 客户端发送 SYN 报文到服务器, 进入 `SYN_SEND` 状态
   2. 服务端接收到 SYN 报文, 进入 `SYN_RECV` 状态
2. 第二个SYNC+ACK报文
    1. 服务端回复 SYN+ACK 报文, 进入 `SYN_RECV` 状态
    2. 客户端接收到 SYN+ACK 报文, 进入 `ESTABLISHED` 状态
3. 第三个ACK报文
    1. 客户端回复 ACK 报文, 进入 `ESTABLISHED` 状态
    2. 服务端接收到 ACK 报文, 进入 `ESTABLISHED` 状态

### 为什么需要三次握手?

1. 阻止重复历史连接的初始化
    1. 当旧的 SYN 报文先到达服务端，服务端回⼀个ACK+SYN报文
    2. 客户端收到后可以根据⾃⾝的上下文，判断这是⼀个历史连接（序列号过期或超时）
    3. 那么客户端会发送 RST, 终止这次连接
    4. 两次握手在收到服务端的响应后开始发送数据，不能判断当前连接是否是历史连接
    5. 三次握手可以在客户端准备发送第三次报文时, 有足够的上下文判断当前连接是否是历史连接
2. 可以同步双方的初始化序列号
3. 确认双方能正确的接收和发送数据
4. 避免资源浪费

## 四次挥手

### 四次挥手的流程是什么样的?

1. 第一个FIN报文
    1. 客户端发送 FIN 报文, 进入 `FIN_WAIT1` 状态
    2. 服务端接收到 FIN 报文, 进入 `CLOSE_WAIT` 状态
2. 第二个ACK报文
    1. 服务端回复 ACK 报文, 进入 `CLOSE_WAIT` 状态
    2. 客户端接收到 ACK 报文, 进入 `FIN_WAIT2` 状态
3. 第三个FIN报文
    1. 服务端发送 FIN 报文, 进入 `LAST_ACK` 状态
    2. 客户端接收到 FIN 报文, 进入 `TIME_WAIT` 状态
4. 第四个ACK报文
    1. 客户端回复 ACK 报文, 进入 `TIME_WAIT` 状态
    2. 服务端接收到 ACK 报文, 进入 `CLOSED` 状态
5. 客户端等待 2MSL 后, 进入 `CLOSED` 状态

### 为什么需要四次挥手?

- 关闭连接时，客户端发送 `FIN` 报文，表示客户端没有数据要发送了, 但是服务端可能还有数据要发送, 所以还能接收数据
- 服务端接收到 `FIN` 报文后, 会回复 `ACK` 报文, 表示已经接收到了客户端的 `FIN` 报文, 但是服务端可能还有数据要发送, 所以还能发送数据
- 等到服务端数据发送完毕，清理完毕后, 会发送 `FIN` 报文, 表示服务端没有数据要发送了

### 为什么 TIME_WAIT 状态需要等待 2MSL?

- MSL 指的是最大报文段生存时间, 也就是报文在网络中最长的生存时间, 超过这个时间，报文将被丢弃
- 等待 2MSL: 是因为网络中可能存在发送方的数据包，当这些发送⽅的数据包被接收⽅处理后又会向对⽅发送响应，
所以⼀来⼀回需要等待 2 倍的时间。
- 2MSL 是从客户端接收到 FIN 后发送 ACK 开始及时，如果在 TIME_WAIT 时间内, ACK
没有传输到服务端，客户端又接收到了服务端重发的 FIN 报文，那么 2MSL 时间将重新计时
- 也就保证了最后一个 ACK 报文能够到达服务端

### 为什么需要 TIME_WAIT 状态?

1. 防止相同的 `四元组` 的 `旧数据` 被收到
2. 保证被动关闭连接的一方能正确的关闭，即保证最后的 ACK 能让被动关闭⽅接收

有相同端⼜的 TCP 连接被复⽤后，被延迟的相同四元组的数据包抵达了客户端，那么客户端是有可能正常接收这个
过期的报⽂，这就会产⽣数据错乱等严重的问题。 

经过 2MSL 这个时间，⾜以让两个⽅向上的数据包都被丢弃，使得原来连接的数据包在⽹络中都⾃然消失，再出现
的数据包⼀定都是新建⽴连接所产⽣的。

### TIME_WAIT 过多有什么危害?

1. 内存资源占用
2. 端口资源占用, 一个TCP至少消耗一个本地端口号

## TCP

## HTTP/HTTPS

## HTTP2

## HTTP3
