# 数据库

## Mysql

### 基础

#### **MySQL索引有几种?**

1. 普通索引: 最基础的索引
2. 唯一索引: 索引列的值必须唯一, 但是允许有空值
3. 主键索引: 索引列的值必须唯一, 且不允许有空值
4. 组合索引: 一个索引包含多个字段
5. 全文索引: 用于全文搜索的索引, 只能在 `MyISAM` 引擎上使用

#### **索引常见类型有哪些?**

1. 哈希表: 适用于等值查询, 不适用于范围查询, 因为没有排序
2. B+树: 适用于等值查询和范围查询, 也适用于模糊查询

#### **说一下 B+ 树的特点?**

本质上是 N 叉树, 折中考虑了`查询效率`和`读取磁盘次数`的平衡

1. 所有数据都存储在叶子节点上
2. 每一层都有很多节点
3. 根据叶子节点的内容, 分为二级索引(为主键索引)和聚集索引(主键索引)
    - 二级索引: 叶子节点存储的是 `主键值`
    - 聚集索引: 叶子节点存储的是 `整行数据`

#### **主键查询和普通索引查询有什么区别?**

1. 主键查询: 通过主键索引查询, 直接定位到 `聚集索引`, 一次查询完成
2. 普通索引查询: 通过普通索引查询, 先定位到 `二级索引`, 拿到主键值, 再定位到 `聚集索引`, 两次查询完成

所以, 主键查询的效率要高于普通索引查询, 需要尽可能的使用主键查询

#### **索引覆盖是什么?**

- 如果一个索引包含了`所有需要查询的字段`, 那么就`不需要回表查询`了, 这种情况就叫做`索引覆盖`
- 因此在二级索引中，就可以给直接查到结果，不需要回表
- 由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使⽤覆盖索引是⼀个常⽤的性能优化⼿段


#### **如何优化索引?**

1. 避免在 where 子句中对字段进行 `null 值` 判断, 否则将导致引擎放弃使用索引而进行全表扫描
2. 字段值分布很少的字段不适合建立索引, 因为索引的最终目的是为了提高查询效率, 如果字段值分布很少, 那么即使使用了索引, 也不会提高查询效率
3. 字符字段用前缀索引, 如果一个字段的数据长度很长, 那么索引的效率就会很低, 因为索引文件本身也很大, 会消耗大量的内存, 所以对于字符字段, 如果可以使用前缀索引, 就尽量使用前缀索引
4. 使⽤多列索引时，注意顺序和查询条件保持⼀致，同时删除不必要的单列索引

#### **有哪些表优化的方法?**

1. 选择正确的存储引擎
2. 选择合适的字段类型
  1. 尽量使用 TINYINT、SMALLINT、MEDIUMINT、代替 INT
  2. 尽量使用 整数或者枚举类型 代替 字符串类型
  3. 时间尽量使用 TIMESTAMP 而不是 DATETIME => TIMESTAMP(4B)，DATETIME(8B)
3. 单表不要放太多的字段，尽量拆分成多个表
4. 尽量少用 NULL 字段 => 很难查询优化且占用索引额外空间

#### **如果项目出现了慢查询，你会怎么优化?**

1. 通过慢查询日志，找到慢查询的 SQL
```sql
# 查看慢查询日志是否开启
show variables like 'slow%'。
# 开启慢查询日志
set global slow_query_log = on
# 查询慢查询的时间阈值
show variables like '%long%'。
# 设置慢查询的时间阈值
set long_query_time=10
# 查询慢查询日志的路径
show variables like '%slow_query_log_file%'。
```
2. 通过 explain 命令, 显⽰mysql如何使⽤索引来处理select语句以及连接表
```sql
explain select * from user where id = 1
```
3. 考虑建立索引的场景
4. 根据业务场景考虑解决方案，比如 `添加缓存、读写分离、分库分表` 等

#### **索引失效的情况有哪些?**

1. 模糊查询以 `%` 开头
2. OR 有一边的条件字段没有索引
3. 使用复合索引时, 如果查询条件没有使用到左侧的字段, 则无法使用索引(最左匹配原则)
4. 在 `WHERE` 当中索引列参与了 `计算、函数、类型转换` 等, 会导致索引失效

#### **最左匹配原则是什么?**

- 如果一个索引包含了多个字段, 那么在查询时, 只有满足最左侧的字段, 才能使用到这个索引

#### **索引下推是什么?**

- 在 MySQL 5.6 版本之后, 优化器会在索引上执行条件过滤, 这个过程称为 `索引下推`
```sql
select * from tuser
where name like 'Q %'
and age=99
and ismale=0;
```
- 根据前缀索引规则，这个语句在搜索索引树的时候，只能⽤ “Q”，找到第⼀个满⾜条件的记录
- 在 MySQL 5.6 之前，只能从 ID3 开始 `⼀个个回表`，到主键索引上找出数据⾏，再对⽐字段值
- 以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满⾜条件的记录，减少回表次数

#### **索引的优点和缺点是什么?**

1. 优点
    - 加快查询速度
    - 大大减少了服务器需要扫描的数据量
    - 可以帮助服务器避免排序和临时表
    - 可以将随机 I/O 变为顺序 I/O
2. 缺点
    - 索引会占用磁盘空间, 一个索引对应一个B+树, 每个节点 16KB
    - 索引需要维护, 降低了数据的维护速度
    - 索引的创建需要时间, 在数据量大的时候, 会花费很多时间
    - 索引只能加快查询速度, 不能加快更新表的速度

#### **建立索引的原则是什么?**

1. 索引不是越多越好, 因为索引也是需要占用空间的, 并且会影响到数据的`增删改`
2. 不经常使用的字段不要建立索引
3. 频繁更新的字段不要建立索引

### 表连接

#### **内连接、左连接、右连接、全连接的区别?**

::: tip 知识点
- 第一个需要操作的表为驱动表，第二个需要操作的表为被驱动表
- 左外连接: 语句左侧的表为驱动表
- 右外连接: 语句右侧的表为驱动表
:::

- 内连接: 驱动表中的记记录在被驱动表中有匹配的记录才会被查询出来, 如果找不到匹配的记录则不会被查询出来
- 左/右(外)连接: 驱动表中的记录都会被查询出来, 如果被驱动表中没有匹配的记录则显示为 NULL

#### 表连接中,where 和 on 的区别?

- where: 在查询结果 `返回之后`, 对结果进行过滤
- on: 在查询结果 `返回之前`, 对结果进行过滤
    - 在内连接中, where 和 on 等价
    - 在外连接中, 如果被驱动表中没有匹配的记录, where 过滤后不会显示, on 过滤后会显示为 NULL

#### **表连接时，索引使用情况是什么样的?**

- 根据驱动表的的一条记录去被驱动表中查找时候，相当于确定条件的单表查询, 可以使用索引优化单表查询
- 在被驱动表上使用二级索引进行查询时，可能连接查询的变量和过滤条件都是二级索引的部分列，可以不用回表直接覆盖索引，所以最好不要用 `*` 作为查询列表，而是使用真正需要查询的列

### 锁

#### **MySQL 锁分为哪几种? 分别有什么特点?**

1. **全局锁**: 对整个 `数据库实例` 加锁, 一般用于全库逻辑备份
```sql
# 添加全局读锁
flush tables with read lock
```
- 执行后以下语句会被 `阻塞`
    - 数据的增删改
    - 数据定义语句
    - 更新类事务的提交语句
2. **表级锁**: 每次操作锁住整张表、开销小、并发度最低
```sql
# 添加表级读/写锁
lock tables user read/write
```
- 可以用 `unlock tables` 释放锁, 也可以在客户端断开连接后自动释放
3. **行级锁**: 每次操作锁住一行记录、开销大、并发度最高(冲突概率最低)
- InnoDB 支持行级锁, 是在需要的时候才加锁, 但是并不是不需要了就立刻释放锁, 而是要等到`事务结束`才释放(*两段锁协议*)
- 如果事务中需要锁多个行, 要把最可能造成锁冲突的语句放到事务的`最后执行`, 以减少锁冲突的概率

#### **共享锁和排他锁是什么,有什么区别?**

1. 共享锁锁定的资源可以被其他用户读取, 但是不能修改
2. 在进行 `SELECT` 的时候，可以将对象进行共享锁定，当数据读取完毕后，就会释放共享锁, 可以保证在读取的过程中，数据 `不会被其他用户修改`
```sql
# 对 id = 1 的记录加共享锁
SELECT id FROM t_user WHERE id = 1 LOCK IN SHARE MODE
```
3. 排他锁锁定时，其他事务无法对已经加锁的资源进行`读取和修改`
```sql
# 对 id = 1 的记录加排他锁
SELECT id FROM t_user WHERE id = 1 FOR UPDATE
```
4. 如果对数据进行更新的时候(INSERT、UPDATE、DELETE)，会自动给数据加上排他锁
5. 共享锁和排他锁不仅可以锁定一行数据，还可以锁定表
```sql
# 对 t_user 表加共享锁
LOCK TABLES t_user READ
# 对 t_user 表加排他锁
LOCK TABLES t_user WRITE
# 释放锁
UNLOCK TABLE
```

#### **乐观锁和悲观锁是什么,有什么区别?**

1. 悲观锁: 适合写操作比较多的场景, 总是假设最坏的情况, 每次去拿数据的时候都认为别人会修改, 所以每次在拿数据的时候都会上锁, 这样别人想拿这个数据就会阻塞直到它拿到锁
2. 乐观锁: 适合读操作比较多的场景, 总是假设最好的情况, 每次去拿数据的时候都认为别人不会修改, 所以不会上锁, 但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据, 可以使用版本号机制或者 `CAS算法` 实现

### 事务

::: tip 知识点
- 一个最小的不可再分的工作单元
- 通常情况下，一个事务对应一个完整的业务
:::

#### **事务的特性是什么?**

`ACID`

1. 原子性: 事务中的所有操作要么全部成功，要么全部失败回滚
2. 一致性: 事务执行前后，数据库的完整性不能被破坏
3. 隔离性: 事务之间是相互隔离的，一个事务不应该影响其他事务
4. 持久性: 事务一旦提交，对数据库的修改是永久性的

#### **事务的隔离级别有哪些?**

::: tip 知识点
脏读: 一个事务读取到了另一个事务未提交的数据
不可重复读: 一个事务读取到了另一个事务已经提交的数据
幻读: 一个事务读取到了另一个事务已经提交的新增数
:::

1. **读未提交**: 事务与事务之间完全不隔离。会产生`脏读`。一般不使用
2. **读已提交**: 事务读取到的是其它事务提交的最新数据。但在同一个事务中，前后两相同的查询可能会读取到不同的数据。会产生 `不可重复读`
3. **可重复读**: 同一个事务中, SELECT 的结果是事务开始时间的状态，不会受到其他事务的影响。但是会产生 `幻读`
4. **串行化**: 事务之间完全隔离，事务只能一个接着一个地执行，不能并发执行。

